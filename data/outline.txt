
# Follow procedure as outlined in jupyter notebook

 1) Construct vstacked matrix
    i) Cov matrix
 2) Perform Linalg Solver
    i) Linear Algebra class
        a) Matrix Inversion - Carefull around singularity
        b) Transposition (Reuse C-code from Camb labs)
        c) Matrix Multiplication
 3) Back-testing by moving forward w rolling window 12 at a time (100 - wide)
    i) Target_return = np.linspace(0, 0.1, 21)

Vector Matrixx::solver(Vector b) {
    // requires non-singular matrix
    if (M.empty() || M[0].size() != M.size()) {
        throw std::invalid_argument("Matrix dimensions are not compatible for inversion");
    }
    // requires positive semi-definite matrix.
    // computationally expensive to calculate eigenvaules so checked in calculation
    int k;
    double tol = 0.00001;  // Typical tolerance 10e âˆ’ 6
    Vector x0, s0, p0;  // Needs to be defined <========================
    Vector x = x0, s = s0, p = p0, a, sOld, B;
    do {
        a = s.transpose() * s / p.transpose() * M * p;
        x = x + a * p;
        sOld = s;
        s = s - a * M * p;
        B = s.transpose() * s / sOld.transpose() * sOld;
        p = s + B * p;
        k+=1;
    } while (sOld.tranpsose()*sOld <= tol);    // Do we need a vector class that is child of matrix?
    return {x};
}

class ConjugateGradientMethod : public MatrixCalculator {
public:
    vector<double> conjugate_gradient(const vector<vector<double> >& Q, const vector<double>& b, vector<double> x0, double tol=1e-6) {
        vector<double> s0 = vectorSubtraction(b, matrixVectorProduct(Q, x0));
        vector<double> p0 = s0;
        int i = 0;
        while (dotProduct(s0, s0) > tol) {
            double alpha = dotProduct(s0, s0) / dotProduct(matrixVectorProduct(Q, p0), p0);
            x0 = vectorAddition(x0, scalarVectorProduct(alpha, p0));
            vector<double> s1 = vectorSubtraction(s0, scalarVectorProduct(alpha, matrixVectorProduct(Q, p0)));
            double beta = dotProduct(s1, s1) / dotProduct(s0, s0);
            p0 = vectorAddition(s1, scalarVectorProduct(beta, p0));
            s0 = s1;
            i++;
            cout << "This is iteration number: " << i << "\n";
            cout << "The current x0 is: ";
            for (const auto& x : x0) {
                cout << x << " ";
            }
            cout << "\n";
        }
        return x0;
    }
};